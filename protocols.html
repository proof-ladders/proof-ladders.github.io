<!DOCTYPE html>
<html lang="en-US">
<head>
  <meta charset="UTF-8">

  <!-- Begin Jekyll SEO tag v2.3.0 -->
  <title>Protocols Proof Ladder - Index</title>

<link rel="stylesheet" href="ressources/iconify.css" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/iconoir-icons/iconoir@main/css/iconoir.css" />  
  <link rel="stylesheet" href="ressources/style.css">
<style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>

<!-- extra style definitions for nice blocks -->

    <style>
.note, .tip, .important, .warning, .caution, .todo {
    padding: 0.7em;
}

.note {
	border-left: solid #0969da 6px;
	border-radius: 4px; 
}

.tip {
	border-left: solid #1a7f37 6px;
	border-radius: 4px; 
}

.important {
	border-left: solid #8250df 6px;
	border-radius: 4px; 
}
.warning {
	border-left: solid #9a6700 6px;
	border-radius: 4px; 
}

.caution {
	border-left: solid #cf222e 6px;
	border-radius: 4px; 
}

.todo {
	border-left: solid #fffd34 6px;
	border-radius: 4px; 
}

    </style>
</head>

<body>
  <a id="anchor-top"></a>
  <section class="page-header">
    <!-- <div class="logo-container"> <img src="logo.png" class="logo" > </div>     -->
    <div class="title-buttons">
      <a href="index.html"><h1 class="project-tagline">Crypto Proof Ladders</h1></a> 
    <center>
	An introduction to formal methods for Cryptography</center>
<center>
  <br/>
  <a class="btn" href="index.html"><span class="iconify ic--round-home"></span> Homepage</a>  
  <a class="btn" href="protocols.html"><i class="iconify iconoir--data-transfer-both"></i> Protocols</a>  
<a class="btn" href="symmetric.html"><i class="iconify ion--key"></i> Symmetric</a>      
  <a class="btn" href="asymmetric.html"><i class="iconify si--lock-fill"></i> Asymmetric</a>      

   </center>
        </div>
  </section>

  <div>
    <section class="main-content">

      <h1></h1>

<!-- do not indent this line, may cause indentation problems in fenced code blocks! -->
<p>The protocol repository is <a
href="https://github.com/proof-ladders/protocol-ladder">here</a>. The
problem set is presented in a <a
href="https://github.com/proof-ladders/protocol-ladder/blob/main/Notes/main.pdf">pdf
file</a>, we recommend to start the reading.</p>
<p>If you are familiar with formal methods, the <a
href="https://github.com/proof-ladders/protocol-ladder">README of the
protocol repository</a> gives you the keys to navigate the set of
proposed solutions. If you are not, we give below an introductory
step-by-step tutorial to the analysis of one of the problems, with key
insights into its modeling using CryptoVerif <span class="citation"
data-cites="cryptoverif"><a href="#ref-cryptoverif"
role="doc-biblioref">[1]</a></span>, EasyCrypt <span class="citation"
data-cites="easycrypt"><a href="#ref-easycrypt"
role="doc-biblioref">[2]</a></span>, ProVerif <span class="citation"
data-cites="proverif"><a href="#ref-proverif"
role="doc-biblioref">[3]</a></span>, Tamarin <span class="citation"
data-cites="tamarin"><a href="#ref-tamarin"
role="doc-biblioref">[4]</a></span> and Squirrel <span class="citation"
data-cites="squirrel"><a href="#ref-squirrel"
role="doc-biblioref">[5]</a></span>. We present how one thinks about
modeling a protocol in a formal way, by going through the signed Diffie
Helman key-exchange (problem 2). We assume that people are familiar with
finite groups, signatures and hash functions.</p>
<h1 id="modeling-the-protocol-wip">Modeling the protocol (‚è≥ üöß WIP üöß
‚è≥)</h1>
<p>To model a protocol, we have to model the computations made by a
given agent, how it receives/send values over the network, and then
define concrete execution scenarios where multiple agents can interact
together.</p>
<h2 id="abstract-functions-and-domains">Abstract functions and
domains</h2>
<p>In any model, we start by specifying at which level of abstraction we
are going to work for the primitives and computations made by our
protocol agents. This part can be seen as defining the interface of a
library that our protocol relies on. When faced with a real word
example, we already have several choices. Do I model my hash function as
a single unary abstract hash function, or as a hmac based on an abstract
hash function, or a hmac based on a fixed block iterated hash function,
and so on. For our problem, which is a high-level specification, we
already have the layer of abstraction, we need to define abstract
signatures, hash functions and a DH group, and not specify more than
that how they might actually be instantiated.</p>
<div class="note">
<p><span style="color: #0969da;">üóÖ Note</span></p>
<p>In this first step, we only care about modeling correctness
conditions of those primitives, so that our protocol does execute,
security notions will be discussed later.</p>
</div>
<p>Let‚Äôs consider the case of signatures. We have to define the way to
sample keys. Already, many small variants appear depending on the tools
capabilities. While those differences might not look very deep, they can
lead to subtle differences in the final guarantees, we thus take the
time to brieffly go through them. EasyCrypt can define abstract
functions that can be either deterministic or probabilistic, we only
have to define domains for the public keys, private keys, signatures and
messages, and then say that a signature has the three desired algorithms
of the expected types.</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode crosstoolsyntax"><code class="sourceCode crosstoolsyntax"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* EasyCrypt *)</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">pkey</span>, <span class="dt">skey</span>, <span class="dt">sig</span>, <span class="dt">msg</span><span class="ot">.</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="kw">type</span> SigScheme = <span class="ot">{</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">proc</span> keygen<span class="ot">()</span>: <span class="dt">pkey</span> * <span class="dt">skey</span>               </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">(* from no arguments, probabilistic procedure returns a pair of type pkey * skey *)</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">proc</span> sign<span class="ot">(_</span>: <span class="dt">skey</span>, <span class="ot">_</span>: <span class="dt">msg</span><span class="ot">)</span>: <span class="dt">sig</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">proc</span> verify<span class="ot">(_</span>: <span class="dt">pkey</span>, <span class="ot">_</span>: <span class="dt">msg</span>, <span class="ot">_</span>: <span class="dt">sig</span><span class="ot">)</span>: <span class="dt">bool</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="ot">}.</span></span></code></pre></div>
<p>Interestingly, some tools that typically cannot prove executability
properties (for sanity checks) do not need to declare the correctness
property of the signature and verify functions, as they might not be
needed to actually prove the security. In the EasyCrypt example, the
correctness is typically not given.</p>
<p>The other tools can only define abstract deterministic functions
(which is actually usefull on the proving side), so we have to make
explicit the randomness as parts of the argument. Typically, the keygen
function needs a new seed, for which we also define a domain, and the
signature also need an addition source of randomness. Both in Squirrel
and CryptoVerif, declaratations are rather similar and we can use an
equation to define the correctness of the verification function.</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode crosstoolsyntax"><code class="sourceCode crosstoolsyntax"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* CryptoVerif *)</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">keyseed</span> [large,fixed]<span class="ot">.</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="co">(* [large,fixed] =&gt; all elements are, given a security parameter, of a</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="co">fixed length, and with negligible chance of collisions. *)</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">pkey</span> [bounded]<span class="ot">.</span> <span class="co">(* [bounded] =&gt; all elements have a maximal length. *)</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">skey</span> [bounded]<span class="ot">.</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> skgen<span class="ot">(</span><span class="dt">keyseed</span><span class="ot">)</span> : <span class="dt">skey</span><span class="ot">.</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> pkgen<span class="ot">(</span><span class="dt">keyseed</span><span class="ot">)</span> : <span class="dt">skey</span><span class="ot">.</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a><span class="co">(* bitstring is a default builtin type *)</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> SIGsign<span class="ot">(</span><span class="dt">bitstring</span>, <span class="dt">skey</span><span class="ot">)</span>: <span class="dt">bitstring</span><span class="ot">.</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> SIGverify<span class="ot">(</span><span class="dt">bitstring</span>, <span class="dt">pkey</span>, <span class="dt">bitstring</span><span class="ot">)</span>: <span class="dt">bool</span><span class="ot">.</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a><span class="kw">equation</span> <span class="kw">forall</span> m : <span class="dt">bitstring</span>, r : <span class="dt">keyseed</span><span class="ot">;</span> </span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>    SIGverify<span class="ot">(</span>SIGsign<span class="ot">(</span>m, skgen<span class="ot">(</span>r<span class="ot">))</span>, m, pkgen<span class="ot">(</span>r<span class="ot">))</span> = true<span class="ot">.</span></span></code></pre></div>
<p>In some tools, we tend to consider that we don‚Äôt have a seed used to
derive keypairs, but rather that we sample uniformly at random a secret
key, and have a way to derive a public key from a secret key. The actual
declaration looks like this.</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode crosstoolsyntax"><code class="sourceCode crosstoolsyntax"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* Squirrel *)</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">skey</span> [large]<span class="ot">.</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">pkey</span><span class="ot">.</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="co">(* message is a default builtin type *)</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="kw">abstract</span> pk : <span class="dt">skey</span> -&gt; <span class="dt">pkey</span><span class="ot">.</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="kw">abstract</span> SIGsign : <span class="dt">message</span> * <span class="dt">skey</span> -&gt; <span class="dt">message</span><span class="ot">.</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="kw">abstract</span> SIGverify : <span class="dt">message</span> * <span class="dt">message</span> * <span class="dt">pkey</span> -&gt; <span class="dt">bool</span><span class="ot">.</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="kw">axiom</span> [any] SIGverify<span class="ot">_</span>correct <span class="ot">(</span>x,y : <span class="dt">message</span>, k : <span class="dt">skey</span><span class="ot">)</span> : </span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>     SIGverify<span class="ot">(</span>SIGsign<span class="ot">(</span>x,k<span class="ot">)</span>, x, pk<span class="ot">(</span>k<span class="ot">)).</span></span></code></pre></div>
<p>This model is also common for ProVerif/Tamarin, and more generally
the symbolic model.</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode crosstoolsyntax"><code class="sourceCode crosstoolsyntax"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* ProVerif *)</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">skey</span><span class="ot">.</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">pkey</span><span class="ot">.</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> pk<span class="ot">(</span><span class="dt">skey</span><span class="ot">)</span> : <span class="dt">pkey</span><span class="ot">.</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> SIGsign<span class="ot">(</span><span class="dt">bitstring</span>, <span class="dt">skey</span><span class="ot">)</span> : <span class="dt">bitstring</span><span class="ot">.</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="kw">reduc</span> <span class="kw">forall</span> m : <span class="dt">bitstring</span>, k : <span class="dt">skey</span><span class="ot">;</span> </span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    SIGverify<span class="ot">(</span>SIGsign<span class="ot">(</span>m,k<span class="ot">)</span>,m, pk<span class="ot">(</span>k<span class="ot">))</span> = true<span class="ot">.</span> </span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span class="co">(* SIGverify is directly defined through the equation is verifies. *)</span></span></code></pre></div>
<p>Tamarin is a corner case where we do not define any specific domain
or type, everything is of the same message type, one defines functions
with their arity, and then the equations over them.</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode crosstoolsyntax"><code class="sourceCode crosstoolsyntax"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* Tamarin *)</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="kw">functions</span>: skgen/1, pkgen/1, SIGsign/2, SIGverify/3, True/0</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="kw">equations</span>: SIGverify<span class="ot">(</span>SIGsign<span class="ot">(</span>m, skgen<span class="ot">(</span>seed<span class="ot">))</span>,m, pkgen<span class="ot">(</span>seed<span class="ot">))</span> = True</span></code></pre></div>
<div class="tip">
<p><span style="color: #1a7f37;">üí° Tip</span></p>
<p>Most tools offer builtins supports or library, we don‚Äôt have to
redefine everything from scratch all the time.</p>
</div>
<h2 id="modeling-an-agent">Modeling an agent</h2>
<p>We have modeled the library that agents will have access to. We now
need to model how one session of an agent may sequentially execute the
protocol, and notably receive or send messages on the network. The
network is assumed to be attacker controlled, we thus do not make a
distinction between arguments received over a network or given by an
attacker.</p>
<div class="important">
<p><span style="color: #8250df;">üñπ Important</span></p>
<p>In the remaining code snippets, we assume that all declarations have
taken place, we thus have functions to compute Hash() and DH operations,
as well as corresponding types. We do not detail it, and use explicit
names everywhere.</p>
</div>
<div class="caution">
<p><span style="color: #cf222e;">‚ö† Caution</span></p>
<p>For this part, tools have disparate input languages with distinct
philosophy, we present the three main variants below. The two main
couple of points to look for are:</p>
<ul>
<li>how are new random values sampled?</li>
<li>how do I send or receive values over the network?</li>
</ul>
</div>
<h3 id="oracleprocedure-based">Oracle/procedure based</h3>
<p>One can define an agent through a set of oracles given to the
attacker. Each oracle model one input/output action of an agent, where
the inputs of the oracle are the inputs received over the network, and
the return value of the oracle.</p>
<p>A multiple step agent is defined by ‚Äúcomposing‚Äù sequentially some
oracles, where the follow-up oracle inherits the state of the previous
ones. For the Signed DH protocol, we need two oracles for the client as
it receives two inputs, and a single one for the server.</p>
<p>This syntax is close to what cryptographers use, and is typically
used in CryptoVerif and EasyCrypt.</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode crosstoolsyntax"><code class="sourceCode crosstoolsyntax"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* CryptoVerif *)</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="co">(* We declare an explicit function to generate DH keypairs. *)</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="kw">letfun</span> DHkeygen<span class="ot">()</span> =</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>       a &lt;-R <span class="dt">Z</span><span class="ot">;</span>     <span class="co">(* this samples in the exponents Z. *)</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>       <span class="ot">(</span>a, exp<span class="ot">(</span>g,a<span class="ot">)).</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="co">(* Client process *)</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="co">(* We declare a macro parametrized by a Server public key </span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a><span class="co">and a hash function, we&#39;ll see how to instantiate it later on. </span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a><span class="co">*)</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> Client<span class="ot">(</span>hf : <span class="dt">hashfunction</span>, s<span class="ot">_</span>pkC : <span class="dt">pkey</span><span class="ot">)</span> =</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>  <span class="co">(* First oracle, that does not have any input. *)</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>  OC1<span class="ot">()</span> :=</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="ot">(</span>x<span class="ot">_</span>sk : <span class="dt">Z</span>, x<span class="ot">_</span>pk : <span class="dt">G</span><span class="ot">)</span> = DHkeygen<span class="ot">()</span> <span class="kw">in</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span><span class="ot">(</span>x<span class="ot">_</span>pk<span class="ot">);</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">(* Second oracle, in sequential composition. *)</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">(* Directly expects two arguments, rather than a pair. *)</span></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>    OC3<span class="ot">(</span>y<span class="ot">_</span>pk : <span class="dt">G</span>, s : <span class="dt">bitstring</span><span class="ot">)</span> :=</span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>      <span class="kw">if</span> SIGverify<span class="ot">(</span>s, msg2<span class="ot">(</span>x<span class="ot">_</span>pk, y<span class="ot">_</span>pk<span class="ot">)</span>, s<span class="ot">_</span>pkC<span class="ot">)</span> <span class="kw">then</span>    </span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>        kC &lt;- Hash<span class="ot">(</span>hf, exp<span class="ot">(</span>y<span class="ot">_</span>pk, x<span class="ot">_</span>sk<span class="ot">));</span></span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0</span><span class="ot">.</span></span></code></pre></div>
<div class="todo">
<p><span style="color: ##fffd34;">‚öô WIP/TODO </span></p>
<p>EasyCrypt syntax examples</p>
</div>
<h3 id="pi-calculus-style">Pi-calculus style</h3>
<p>To model agents, a pi-calculus dialect makes us write in an
imperative programing style, with <code>let</code> bindings, conditional
branchings, but also add two commands for network interactions,
<code>in(c,x)</code> and <code>out(c,t)</code>, which models receiving a
value over the network and binding it to variable <code>x</code> or
sending out value <code>t</code> on the network. The value
<code>c</code> is meant to model a particular channel. Channels can be
useful to model secret communications between agents, otherwise, having
a single public channel is often enough. The last pi-calculus command is
<code>new x : type</code>, which binds variable <code>x</code> to a new
value in the type. This is akin to the sampling of a fresh value. We can
model the client side protocol as follows in ProVerif.</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode crosstoolsyntax"><code class="sourceCode crosstoolsyntax"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* ProVerif *)</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="co">(* We declare an explicit function to generate DH keypairs. *)</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="kw">letfun</span> DHkeygen<span class="ot">()</span> =</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>       new a : <span class="dt">Z</span><span class="ot">;</span> <span class="co">(* this samples a new value in the exponents. *)</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>       <span class="ot">(</span>a, exp<span class="ot">(</span>g,a<span class="ot">)).</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>       </span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span class="co">(* Client process *)</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="co">(* We declare a macro parametrized by a Server public key, we&#39;ll see</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a><span class="co">how to instantiate it later on. *)</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> Client<span class="ot">(</span>s<span class="ot">_</span>pk : <span class="dt">pkey</span><span class="ot">)</span> = </span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">(* First message *)</span>   </span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">(* No input needed *)</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="ot">(</span>x<span class="ot">_</span>sk : <span class="dt">Z</span>, x<span class="ot">_</span>pk : <span class="dt">G</span><span class="ot">)</span> = DHkeygen<span class="ot">()</span> <span class="kw">in</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">out</span><span class="ot">(</span>c, x<span class="ot">_</span>pk<span class="ot">);</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">(* Second message *)</span></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">(* we directly do some pattern matching on the input. *)</span></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">in</span><span class="ot">(</span>c, <span class="ot">(</span>y<span class="ot">_</span>pk : <span class="dt">G</span>,sig : <span class="dt">bitstring</span><span class="ot">));</span></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> SIGverify<span class="ot">(</span><span class="dt">sig</span>, <span class="ot">(</span>x<span class="ot">_</span>pk,y<span class="ot">_</span>pk<span class="ot">)</span>, s<span class="ot">_</span>pk<span class="ot">)</span> <span class="kw">then</span></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>       <span class="kw">let</span> k<span class="ot">_</span>C = Hash<span class="ot">(</span> exp<span class="ot">(</span>y<span class="ot">_</span>pk,x<span class="ot">_</span>sk<span class="ot">))</span> <span class="kw">in</span>       </span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a>       <span class="dv">0</span><span class="ot">.</span></span></code></pre></div>
<p>Squirrel syntax has mainly two diffrences. First, because we can only
receive and send messages of type <code>message</code>, and thus have to
add explicit type conversion functions (akin to
serialization/deserialization functions). Second, in Squirrel, andom
values are represented as ‚Äúnames‚Äù, that can be indexed, e.g.¬†by a
session identifier. Instead of sampling <code>x_sk</code> in the i-th
Session of the Client, it will directly use the value
<code>x_sk i</code>. This is equivalent to assuming that all secret
values were precomputed at the begining of the universe (akin to eager
sampling), and that we stored in an array <code>x_sk</code> the list of
the ephemeral of all clients.</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode crosstoolsyntax"><code class="sourceCode crosstoolsyntax"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* Squirrel *)</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="co">(* We declare the names for the clients. *)</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="co">(* ephemerals for Client  *)</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="kw">name</span> x<span class="ot">_</span>sk : <span class="dt">index</span> -&gt; <span class="dt">Z</span><span class="ot">.</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>       </span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="co">(* Client process *)</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="co">(* We declare a macro parametrized by a session identifier, which is a</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span class="co">replication index, we&#39;ll see how to instantiate it later on. *)</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a><span class="kw">process</span> Client <span class="ot">(</span>i : <span class="dt">index</span><span class="ot">)</span> =</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>  <span class="co">(* We receive some server public key *)</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>  <span class="co">(* We cannot pass this as argument to the Client macro, this is not</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a><span class="co">  a technical limitation, just need some more implementation. *)</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span><span class="ot">(</span>c, s<span class="ot">_</span>pk<span class="ot">);</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>  <span class="co">(* We compute our ephemeral *)</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> x<span class="ot">_</span>sk = x<span class="ot">_</span>sk i <span class="kw">in</span>  <span class="co">(* we use the i-th value of the array x_sk. *)</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> x<span class="ot">_</span>pk = gen^x<span class="ot">_</span>sk <span class="kw">in</span></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>  <span class="kw">out</span><span class="ot">(</span>c, ofG<span class="ot">(</span>x<span class="ot">_</span>pk<span class="ot">));</span></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span><span class="ot">(</span>c, mA<span class="ot">);</span></span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> y<span class="ot">_</span>pk = toG<span class="ot">(</span>fst<span class="ot">(</span>mA<span class="ot">))</span> <span class="kw">in</span></span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="dt">sig</span> = snd<span class="ot">(</span>mA<span class="ot">)</span> <span class="kw">in</span></span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> SIGverify<span class="ot">(</span>&lt; ofG<span class="ot">(</span>x<span class="ot">_</span>pk<span class="ot">)</span>, ofG<span class="ot">(</span>y<span class="ot">_</span>pk<span class="ot">)</span>&gt;, <span class="dt">sig</span>, s<span class="ot">_</span>pk<span class="ot">)</span> <span class="kw">then</span></span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> gCS = y<span class="ot">_</span>pk^x<span class="ot">_</span>sk  <span class="kw">in</span></span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> kC = Hash<span class="ot">(</span> ofG<span class="ot">(</span>gCS<span class="ot">)</span>, kHash<span class="ot">)</span> <span class="kw">in</span></span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a>    null<span class="ot">.</span></span></code></pre></div>
<h3 id="msr-based">MSR based</h3>
<div class="todo">
<p><span style="color: ##fffd34;">‚öô WIP/TODO </span></p>
<p>MSR core ides + Tamarin snippet</p>
</div>
<h2 id="modeling-the-protocol">Modeling the protocol</h2>
<p>To finalize the definition of the protocol, it remains to model the
concrete scenario we are in:</p>
<ul>
<li>with which server public key do we initialize the client?</li>
<li>how many client/server sessions do we set up?</li>
<li>‚Ä¶</li>
</ul>
<h1 id="attacker-model">Attacker Model</h1>
<p>In the presented tool, we always have an active attacker which
controls the network. However, its capabilities differ, the main split
being between the symbolic (Proverif/Tamarin) and the computational
(EasyCrypt,CryptoVerif/Squirrel) tools.</p>
<h2 id="computational-attacker">Computational attacker</h2>
<div class="todo">
<p><span style="color: ##fffd34;">‚öô WIP/TODO </span></p>
<p>Very quick description (we assume some crypto knowledge). Give
snippets of uf-cma user defined axioms for EasyCrypt/CryptoVerif.
Mention dedicated tactics for Squirrel + user-defined functions.</p>
</div>
<h2 id="symbolic-attacker">Symbolic attacker</h2>
<p>In the symbolic world, the cryptography is assumed to be ideal.</p>
<div class="important">
<p><span style="color: #8250df;">üñπ Important</span></p>
<p>We keep here the presentation simple. Note that however, symbolic
models have recently been developped to capture in a fine-grained
fashion many primitives, typically capturing the low-order points of
X25519, the length-extension property of SHA2, and other subtle
properties of signatures, KEMs, AEADs,‚Ä¶</p>
<p>In addition, it also enable to model cases where the attacker is in
fact stronger than in the usual computational model, for instance by
letting the attacker chose at run time the output values of a hash
function, as long as it does not make any collision.</p>
<p>Comparing the symbolic and the computational attacker is thus not
compltely straigthforward in some cases, and especially on big protocols
where computational proofs are out of reach.</p>
</div>
<h1 id="security-definitions">Security definitions</h1>
<p>We now turn to actually modeling the security definitions.</p>
<div class="caution">
<p><span style="color: #cf222e;">‚ö† Caution</span></p>
<p>Even tools that model the attacker in the same way may capture the
security with subtle differences, in how secret keys can be compromised,
or with different ways of modelling authentication or secrecy. Clearly
understanding this when reading a model is one of the main
challenge.</p>
</div>
<h2 id="symbolic-security-definitions">Symbolic security
definitions</h2>
<div class="todo">
<p><span style="color: ##fffd34;">‚öô WIP/TODO </span></p>
<p>Notion of events and attacker knwoledge, model compromise inside the
protocol model, snippets of ProVerif queries + Tamarin lemmas.</p>
</div>
<h2 id="computational-security-definitions">Computational security
definitions</h2>
<h3 id="monolithic-ake-style-security">Monolithic AKE style
security</h3>
<div class="todo">
<p><span style="color: ##fffd34;">‚öô WIP/TODO </span></p>
<p>High level summary of AKE notes, link to doc, snippets of
easycrypt?</p>
</div>
<h3 id="split-trace-and-indistinguishability-based-style">Split trace
and indistinguishability based style</h3>
<div class="todo">
<p><span style="color: ##fffd34;">‚öô WIP/TODO </span></p>
<p>Describe the mix approach, both with trace based dedicated
authentication queries, and some indistinguishability based secrecy
queries.</p>
<p>snippets of CryptoVerif / Squirrel queries.</p>
</div>
<h1 id="proving">Proving</h1>
<div class="tip">
<p><span style="color: #1a7f37;">üí° Tip</span></p>
<p>If your only goal was to better understand what kind of guarantees
are actually provided by the different models or tools, you can stop
here!</p>
</div>
<p>We now brieffly delve into how the tools are proved.</p>
<h2 id="automated">Automated</h2>
<div class="todo">
<p><span style="color: ##fffd34;">‚öô WIP/TODO </span></p>
<p>Describe the automated approach, ProVerif Tamarin</p>
<p>A little bit CryptoVerif</p>
</div>
<h3 id="heuristic-guidance">Heuristic guidance</h3>
<div class="todo">
<p><span style="color: ##fffd34;">‚öô WIP/TODO </span></p>
<p>Use of helper lemmas in Tamarin/ProVerif oracles, additional
params.</p>
</div>
<h2 id="interactive-proofs">Interactive Proofs</h2>
<h3 id="logic-based-reasoning">Logic based reasoning</h3>
<div class="todo">
<p><span style="color: ##fffd34;">‚öô WIP/TODO </span></p>
<p>Easycrypt/Squirrel</p>
</div>
<h3 id="restricted-tactic-applications">Restricted tactic
applications</h3>
<div class="todo">
<p><span style="color: ##fffd34;">‚öô WIP/TODO </span></p>
<p>CryptoVerif/Tamarin interactive mode</p>
</div>
<h1 id="additional-ressources">Additional ressources</h1>
<p>That‚Äôs it!</p>
<p>Hopefully, you should now be able to browse the repository and
understand at least at a high-level the models. If you want to delve
deeper into one of the tools, here are for each some additional
ressources.</p>
<div class="todo">
<p><span style="color: ##fffd34;">‚öô WIP/TODO </span></p>
<p>Add links to doc/manual/tutorial for tools!</p>
</div>
<h1 id="wip-guidelines-for-style">WIP guidelines for style</h1>
<div class="note">
<p><span style="color: #0969da;">üóÖ Note</span></p>
<p>This is a note.</p>
</div>
<div class="tip">
<p><span style="color: #1a7f37;">üí° Tip</span></p>
<p>This is a tip.</p>
</div>
<div class="important">
<p><span style="color: #8250df;">üñπ Important</span></p>
<p>This is a warning.</p>
</div>
<div class="warning">
<p><span style="color: #9a6700;">‚ö† Warning</span></p>
<p>This is a warning.</p>
</div>
<div class="caution">
<p><span style="color: #cf222e;">‚ö† Caution</span></p>
<p>This is a warning.</p>
</div>
<div class="todo">
<p><span style="color: ##fffd34;">‚öô WIP/TODO </span></p>
<p>This is a TODO.</p>
</div>
<h1 class="unnumbered" id="references">References</h1>
<div id="refs" class="references csl-bib-body" role="list">
<div id="ref-cryptoverif" class="csl-entry" role="listitem">
<div class="csl-left-margin">[1] </div><div class="csl-right-inline">B.
Blanchet, <span>‚ÄúA computationally sound mechanized prover for security
protocols,‚Äù</span> in <em><span>IEEE</span> Trans. Dependable Secur.
Comput.</em>, 2008, vol. 5, pp. 193‚Äì207, <a
href="https://bblanche.gitlabpages.inria.fr/CryptoVerif/">https://bblanche.gitlabpages.inria.fr/CryptoVerif/</a>.</div>
</div>
<div id="ref-easycrypt" class="csl-entry" role="listitem">
<div class="csl-left-margin">[2] </div><div class="csl-right-inline">G.
Barthe, B. Gr√©goire, S. Heraud, and S. Z. B√©guelin,
<span>‚ÄúComputer-aided security proofs for the working
cryptographer,‚Äù</span> in <em>Advances in cryptology -
<span>CRYPTO</span> 2011 - 31st annual cryptology conference, santa
barbara, CA, USA, august 14-18, 2011. proceedings</em>, 2011, vol. 6841,
pp. 71‚Äì90, <a
href="https://www.easycrypt.info/">https://www.easycrypt.info/</a>.</div>
</div>
<div id="ref-proverif" class="csl-entry" role="listitem">
<div class="csl-left-margin">[3] </div><div class="csl-right-inline">B.
Blanchet and others, <span>‚ÄúModeling and verifying security protocols
with the applied pi calculus and ProVerif,‚Äù</span> in <em>Foundations
and Trends<span></span> in Privacy and Security</em>, 2016, vol. 1, pp.
1‚Äì135, <a
href="https://bblanche.gitlabpages.inria.fr/proverif/">https://bblanche.gitlabpages.inria.fr/proverif/</a>.</div>
</div>
<div id="ref-tamarin" class="csl-entry" role="listitem">
<div class="csl-left-margin">[4] </div><div class="csl-right-inline">S.
Meier, B. Schmidt, C. Cremers, and D. Basin, <span>‚ÄúThe TAMARIN prover
for the symbolic analysis of security protocols,‚Äù</span> in <em>Computer
aided verification: 25th international conference, CAV 2013, saint
petersburg, russia, july 13-19, 2013. Proceedings 25</em>, 2013, pp.
696‚Äì701, <a
href="https://tamarin-prover.com/">https://tamarin-prover.com/</a>.</div>
</div>
<div id="ref-squirrel" class="csl-entry" role="listitem">
<div class="csl-left-margin">[5] </div><div class="csl-right-inline">D.
Baelde, S. Delaune, C. Jacomme, A. Koutsos, and S. Moreau, <span>‚ÄúAn
interactive prover for protocol verification in the computational
model,‚Äù</span> in <em>42nd <span>IEEE</span> symposium on security and
privacy, <span>SP</span> 2021, san francisco, CA, USA, 24-27 may
2021</em>, 2021, pp. 537‚Äì554, <a
href="https://squirrel-prover.github.io/">https://squirrel-prover.github.io/</a>.</div>
</div>
</div>

      <hr>
      <div class="footer-nav">
        <div class="footer-nav-Body">
          <div class="footer-nav-Row">
            <div class="footer-nav-Left">&nbsp;</div>
            <div class="footer-nav-Mid"><a href="#anchor-top">Top</a></div>
            <div class="footer-nav-Right">&nbsp;</div>
          </div>
        </div>
      </div>
    </section>


  </div>
</body>
